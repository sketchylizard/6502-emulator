#!/usr/bin/env python3
"""
Generate a header for Klaus functional tests that:
  - extracts success PC + error trap PCs from .lst
  - emits INCBIN for the adjacent .bin (or provided path), wrapped in extern "C"
  - defines struct Klaus_<sanitized_stem> with success, errors[], and a data() span accessor

Rules:
- After stripping ';' comments and whitespace:
    * line == "success"      -> next non-empty line's first 4-hex token is success PC
    * line == "trap" or startswith "trap_" -> next non-empty line's first 4-hex token is an error PC
"""

from __future__ import annotations
import argparse
import re
from pathlib import Path
from typing import List, Optional

HEX4_AT_START = re.compile(r"^\s*([0-9A-Fa-f]{4})\b")

def strip_comment_ws(line: str) -> str:
    return line.split(";", 1)[0].strip()

def next_nonempty(lines: List[str], i: int) -> Optional[str]:
    j = i + 1
    while j < len(lines):
        s = strip_comment_ws(lines[j])
        if s:
            return lines[j]
        j += 1
    return None

def parse_addr_from_line(raw: str) -> Optional[int]:
    m = HEX4_AT_START.match(raw)
    return int(m.group(1), 16) if m else None

def sanitize_struct_stem(stem: str) -> str:
    # Struct: Klaus_<sanitized>, prefix '_' if starts with digit
    s = re.sub(r"[^A-Za-z0-9_]", "_", stem)
    if not s:
        s = "listing"
    if s[0].isdigit():
        s = "_" + s
    return f"Klaus_{s}"

def symbol_for_incbin(stem: str) -> str:
    # We want g_<symbol>Data / g_<symbol>Size produced by INCBIN(symbol, ...)
    # To match user's example g_Klaus_functionalBinData, make symbol start with '_'
    # e.g. symbol = _Klaus_functionalBin -> g_Klaus_functionalBinData
    s = re.sub(r"[^A-Za-z0-9_]", "_", stem)
    if not s:
        s = "listing"
    if s[0].isdigit():
        s = "_" + s
    return f"_Klaus_{s}Bin"

def chunk4(seq: List[int]) -> List[List[int]]:
    return [seq[i:i+4] for i in range(0, len(seq), 4)]

def gen_header_text(
    struct_name: str,
    incbin_sym: str,
    lst_abs: str,
    bin_path_for_macro: str,
    success_pc: int,
    errors_sorted: List[int],
    namespace: str | None,
) -> str:
    ns_parts = [p for p in (namespace or "").split("::") if p]
    # incbin.h (popular variant) exports: g<sym>Data, g<sym>End, g<sym>Size
    # With our leading underscore in sym, those become g_<sym>Data, etc.
    g_data = f"g{incbin_sym}Data"
    g_size = f"g{incbin_sym}Size"

    out: List[str] = []
    out.append("// Auto-generated by gen_klaus_incbin.py — do not edit.")
    out.append(f"// Source: {lst_abs}")
    out.append("// Credit: Klaus Dormann — https://github.com/Klaus2m5/6502_65C02_functional_tests")
    out.append("#pragma once")
    out.append('#include "common/address.h"')
    out.append("#include <span>")
    out.append('#include "incbin.h"')
    out.append("")
    out.append("extern \"C\" {")
    out.append(f"INCBIN({incbin_sym}, \"{bin_path_for_macro}\");")
    out.append("}")
    out.append("")

    for p in ns_parts:
        out.append(f"namespace {p} {{")
    if ns_parts:
        out.append("")

    out.append(f"struct {struct_name} {{")
    out.append(f"  static constexpr Address success{{0x{success_pc:04X}}};")
    out.append("")
    out.append("  static constexpr Address errors[] = {")
    if errors_sorted:
        for group in chunk4(errors_sorted):
            out.append("      " + ", ".join(f"Address{{0x{x:04X}}}" for x in group) + ",")
    out.append("  };")
    out.append("")
    out.append("  // View over INCBIN()-provided bytes; fixed extent assumes 64 KiB image.")
    out.append(f"  static std::span<Byte, 0x10000> data() noexcept {{")
    out.append(f"    return std::span<Byte, 0x10000>(const_cast<Byte*>({g_data}), {g_size});")
    out.append("  }")
    out.append("};")

    if ns_parts:
        out.append("")
        for p in reversed(ns_parts):
            out.append(f"}} // namespace {p}")
    out.append("")
    return "\\n".join(out)

def main() -> None:
    ap = argparse.ArgumentParser(description="Generate Klaus header with success/errors and INCBIN() span accessor")
    ap.add_argument("lst", type=Path, help=".lst input file")
    ap.add_argument("-o", "--output", type=Path, required=True, help="Output header path")
    ap.add_argument("--namespace", default="", help="Optional C++ namespace, e.g. emu::tests")
    ap.add_argument("--bin-path", type=Path, default=None, help="Path to .bin for INCBIN (default: same stem as .lst)")
    args = ap.parse_args()

    lines = args.lst.read_text(encoding="utf-8", errors="replace").splitlines()

    success_pc: Optional[int] = None
    error_set: set[int] = set()

    i = 0
    while i < len(lines):
        tok = strip_comment_ws(lines[i])
        if tok == "success" or tok == "trap" or tok.startswith("trap_"):
            nxt = next_nonempty(lines, i)
            if nxt is not None:
                addr = parse_addr_from_line(nxt)
                if addr is not None:
                    if tok == "success":
                        success_pc = addr
                    else:
                        error_set.add(addr)
        i += 1

    if success_pc is None:
        raise SystemExit(f"{args.lst}: could not find 'success' followed by an address line.")

    errors_sorted = sorted(error_set)

    bin_path = args.bin_path if args.bin_path is not None else args.lst.with_suffix(".bin")
    if not bin_path.exists():
        print(f"[warn] Binary not found: {bin_path} (INCBIN will still reference it)")

    struct_name = sanitize_struct_stem(args.lst.stem)          # e.g. Klaus__6502_functional_test
    incbin_sym  = symbol_for_incbin(args.lst.stem)             # e.g. _Klaus__6502_functional_testBin

    header = gen_header_text(
        struct_name=struct_name,
        incbin_sym=incbin_sym,
        lst_abs=str(args.lst.resolve()),
        bin_path_for_macro=str(bin_path),
        success_pc=success_pc,
        errors_sorted=errors_sorted,
        namespace=(args.namespace or None),
    )

    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(header, encoding="utf-8")
    print("[ok] Wrote", args.output)
    print("    struct   =", struct_name)
    print("    INCBIN   =", incbin_sym)
    print("    bin path =", bin_path)
    print(f"    success  = 0x{success_pc:04X}")

if __name__ == "__main__":
    main()
